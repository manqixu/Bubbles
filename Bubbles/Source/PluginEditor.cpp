/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "DemoUtilities.h"

//==============================================================================
/** Simple message that holds a Colour. */
struct JuceDemoPluginAudioProcessorEditor::ColourMessage  : public Message
{
    ColourMessage (Colour col)  : colour (col)
    {
    }
    
    /** Returns the colour of a ColourMessage of white if the message is not a ColourMessage. */
    static Colour getColour (const Message& message)
    {
        if (const ColourMessage* cm = dynamic_cast<const ColourMessage*> (&message))
            return cm->colour;
        
        return Colours::white;
    }
    
private:
    Colour colour;
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ColourMessage)
};

//==============================================================================
/** Simple component that can be triggered to flash.
 The flash will then fade using a Timer to repaint itself and will send a change
 message once it is finished.
 */
class JuceDemoPluginAudioProcessorEditor::FlashingComponent   : public Component,
public MessageListener,
public ChangeBroadcaster,
private Timer
{
public:
    FlashingComponent(JuceDemoPluginAudioProcessor& owner)
    : flashAlpha (0.0f),
    colour (Colours::red),
    processor (owner),
    noteNumber(60)
{
    }
    
    void startFlashing()
    {
        flashAlpha = 1.0f;
        startTimerHz (25);
    }
    
    /** Stops this component flashing without sending a change message. */
    void stopFlashing()
    {
        flashAlpha = 0.0f;
        stopTimer();
        repaint();
    }
    
    /** Sets the colour of the component. */
    void setFlashColour (const Colour newColour)
    {
        colour = newColour;
        repaint();
    }
    
    /** Draws our component. */
    void paint (Graphics& g) override
    {
        g.setColour (colour.overlaidWith (Colours::white.withAlpha (flashAlpha)));
        g.fillEllipse (getLocalBounds().toFloat());
    }
    
    /** Custom mouse handler to trigger a flash. */
    void mouseDown (const MouseEvent&) override
    {
        startFlashing();
        noteNumber = rand() % 80 + 20;
        processor.keyboardState.noteOn(1,noteNumber,0.9);
    }
    
    void mouseUp (const MouseEvent&) override
    {
        processor.keyboardState.noteOff(1,noteNumber,0.9);
    }
    
    /** Message listener callback used to change our colour */
    void handleMessage (const Message& message) override
    {
        setFlashColour (ColourMessage::getColour (message));
    }
    
private:
    float flashAlpha;
    Colour colour;
    JuceDemoPluginAudioProcessor& processor;
    int noteNumber;
    
    void timerCallback() override
    {
        // Reduce the alpha level of the flash slightly so it fades out
        flashAlpha -= 0.075f;
        
        if (flashAlpha < 0.05f)
        {
            stopFlashing();
            sendChangeMessage();
            // Once we've finsihed flashing send a change message to trigger the next component to flash
        }
        
        repaint();
    }
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FlashingComponent)
};

//==============================================================================
JuceDemoPluginAudioProcessorEditor::JuceDemoPluginAudioProcessorEditor (JuceDemoPluginAudioProcessor& owner)
    : AudioProcessorEditor (owner)
{
    setOpaque (true);
    setSize(600,600);

    // start a timer which will keep our timecode display updated
    startTimerHz (30);
    
    // Create and add our FlashingComponents with some random colours and sizes
    for (int i = 0; i < numFlashingComponents; ++i)
    {
        FlashingComponent* newFlasher = new FlashingComponent(owner);
        flashingComponents.add (newFlasher);
        
        newFlasher->setFlashColour (getRandomBrightColour());
        newFlasher->addChangeListener (this);
        
        const int diameter = 25 + random.nextInt (75);
        newFlasher->setSize (diameter, diameter);
        
        addAndMakeVisible (newFlasher);
    }
    
    
    // lay out our components in a psudo random grid
    Rectangle<int> area (0, 0, 150, 150);
    
    for (int i = 0; i < flashingComponents.size(); ++i)
    {
        FlashingComponent* comp = flashingComponents.getUnchecked (i);
        Rectangle<int> buttonArea (area.withSize (comp->getWidth(), comp->getHeight()));
        buttonArea.translate (random.nextInt (area.getWidth() - comp->getWidth()),
                              random.nextInt (area.getHeight() - comp->getHeight()));
        comp->setBounds (buttonArea);
        
        area.translate (area.getWidth(), 0);
        
        // if we go off the right start a new row
        if (area.getRight() > 600)
        {
            area.translate (0, area.getWidth());
            area.setX (0);
        }
    }
}

JuceDemoPluginAudioProcessorEditor::~JuceDemoPluginAudioProcessorEditor()
{
    for (int i = flashingComponents.size(); --i >= 0;)
        flashingComponents.getUnchecked (i)->removeChangeListener (this);
}

//==============================================================================
void JuceDemoPluginAudioProcessorEditor::changeListenerCallback (ChangeBroadcaster* source)
{
    for (int i = 0; i < flashingComponents.size() - 1; ++i)
        if (source == flashingComponents.getUnchecked (i)){
                flashingComponents.getUnchecked (rand() % flashingComponents.size())->startFlashing();
        }
}

//==============================================================================
void JuceDemoPluginAudioProcessorEditor::paint (Graphics& g)
{
    File f = (String)"/Users/xumanqi/Desktop/Stanford Fall 2017/MUSIC256A/HW3/Bubbles/Source/bubbles.jpg";
    Image img = ImageFileFormat::loadFrom(f);
    g.drawImageAt(img,0,0,false);
}

//==============================================================================
void JuceDemoPluginAudioProcessorEditor::timerCallback()
{
    updateTimecodeDisplay (getProcessor().lastPosInfo);
}

//==============================================================================
// quick-and-dirty function to format a timecode string
static String timeToTimecodeString (double seconds)
{
    const int millisecs = roundToInt (seconds * 1000.0);
    const int absMillisecs = std::abs (millisecs);

    return String::formatted ("%02d:%02d:%02d.%03d",
                              millisecs / 360000,
                              (absMillisecs / 60000) % 60,
                              (absMillisecs / 1000) % 60,
                              absMillisecs % 1000);
}

// quick-and-dirty function to format a bars/beats string
static String quarterNotePositionToBarsBeatsString (double quarterNotes, int numerator, int denominator)
{
    if (numerator == 0 || denominator == 0)
        return "1|1|000";

    const int quarterNotesPerBar = (numerator * 4 / denominator);
    const double beats  = (fmod (quarterNotes, quarterNotesPerBar) / quarterNotesPerBar) * numerator;

    const int bar    = ((int) quarterNotes) / quarterNotesPerBar + 1;
    const int beat   = ((int) beats) + 1;
    const int ticks  = ((int) (fmod (beats, 1.0) * 960.0 + 0.5));

    return String::formatted ("%d|%d|%03d", bar, beat, ticks);
}

// Updates the text in our position label.
void JuceDemoPluginAudioProcessorEditor::updateTimecodeDisplay (AudioPlayHead::CurrentPositionInfo pos)
{
    MemoryOutputStream displayText;

    displayText << "[" << SystemStats::getJUCEVersion() << "]   "
                << String (pos.bpm, 2) << " bpm, "
                << pos.timeSigNumerator << '/' << pos.timeSigDenominator
                << "  -  " << timeToTimecodeString (pos.timeInSeconds)
                << "  -  " << quarterNotePositionToBarsBeatsString (pos.ppqPosition,
                                                                    pos.timeSigNumerator,
                                                                    pos.timeSigDenominator);

    if (pos.isRecording)
        displayText << "  (recording)";
    else if (pos.isPlaying)
        displayText << "  (playing)";
}
